Ex1-a): O que são Fibonnaci heaps e filas de prioridade mutáveis?
    ->Heaps:https://www.geeksforgeeks.org/heap-data-structure/
        ->Fibonnaci heap: https://www.geeksforgeeks.org/fibonacci-heap-set-1-introduction/
    ->filas de prioridade :https://www.geeksforgeeks.org/priority-queue-set-1-introduction/
        ->https://www.geeksforgeeks.org/queue-data-structure/
     ->Dijkstra's : https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-using-priority_queue-stl/


Ex1-b) Como fazer e qual melhor programa para fazer os gráficos/API em c++->FAzer!




    Refactoring:
        ex1-a):


Ex2-a) https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/
           Mesmo que Dijkstra mas permite arestas com pesos negativos
           E trata o caso para : Se existirem ciclos com peso negativo, o problema não tem solução.
           Como sabemos número máximo de arestas de um vértice até outro pelo número de vértices?!? V- 1?!?
            Programação dinâmica, pois vamos usa uma abordagem bottom-up
            onde se vai melhorando o resultado para o caminho mais curto partindo de casos anteriores já processados
            as tais iterações de 1  a |V| - 1 ( ver melhor isto)->
            Em cada iteração i, o algoritmo processa todas as arestas e garante que
            encontra todos os caminhos mais curtos com até i arestas (e possivelmente
            alguns mais longos) (invariante do ciclo principal).
             Uma vez que o caminho mais comprido, sem ciclos, tem |V|-1 arestas,
            basta executar no máximo |V|-1 iterações do ciclo principal para assegurar
            que todos os caminhos mais curtos são encontrados.
             No final é executada mais uma iteração para ver se alguma distância pode
            ser melhorada; se for o caso, significa que há um caminho mais curto com
            |V| arestas, o que só pode acontecer se existir pelo menos um ciclo de peso
            negativo.
             Podem ser efetuadas algumas melhorias ao algoritmo, mas que mantêm a
            complexidade temporal de O (|V| |E|).


    Refactoring:
        Melhoria para grafos acíclicos como?E como saber de antemão que não é acíclico?

Ex3-a)Matrizes: https://www.geeksforgeeks.org/multidimensional-arrays-c-cpp/
                https://www.geeksforgeeks.org/multidimensional-pointer-arithmetic-in-cc/?ref=rp
                https://www.geeksforgeeks.org/create-dynamic-2d-array-inside-class-c/
                https://pt.wikipedia.org/wiki/Algoritmo_de_Floyd-Warshall
                Na funcao getPathFloyd... usamos while(true) ... break... de forma a que no final
                o vector orig também seja atribuido ao vector dos caminhos em vez de usar v->info()!=orig
                e ter de fazer push no final da função do vertice orig!!